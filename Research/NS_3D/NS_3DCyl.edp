load "iovtk"
load "msh3"

// Variable declaration
real r1 = 1;
real r2 = 0.4;
real r3 = 0.1;
real nu = 1.0;
real delta=1.0;
real T=1.0;
real error, Herror, maxmag;
real errormax = 0, Herrormax = 0;
real t=0, c=0.0625*sqrt(2);

func exactu1 = -cos(x)*sin(y)*cos(z)*exp(-2*t);
func exactu2 = sin(x)*cos(y)*cos(z)*exp(-2*t);
func exactu3 = 0.;
func f1 = -cos(x)*sin(y)*cos(z)*exp(-2*t);
func f2 = sin(x)*cos(y)*cos(z)*exp(-2*t);
func f3 = (-exp(-4*t)/4)*sin(2*z)*(2*cos(2*z)+1);

int[int] rup=[0,1,1,1,2,1], rdown=[0,1,1,1,2,1], rmid=[1,4,2,3,3,3];
real zmin=-1./8,zmax=1./2;

ofstream ff("Cyl_error_3D.txt");
ofstream umag("Max_magnitude.txt");

//iteration for each mesh devider
for(int n=20; n>=4; n=n-4 )
{
  real dt = c*sqrt(1./n); //take dt=c*sqrt(h)
  int Nt = T/dt;
  
  // Create the mesh
  border Gamma1(t=0,2*pi)    { x = r1*cos(t); y = r1*sin(t); }
  border Gamma2(t=0,2*pi)    { x = r2*cos(t); y = r2*sin(t); }
  border Gamma3(t=0,2*pi)    { x = r3*cos(t); y = r3*sin(t); }

  mesh Th2 = buildmesh(Gamma1(n)+Gamma2(n)+Gamma3(n));   // construction of mesh
  mesh3 Th=buildlayers(Th2,n,
    zbound=[zmin,zmax], labelmid=rmid, reffaceup = rup, reffacelow = rdown);
  //plot ( Th, ps = "Cyl_NS_3D_mesh.ps" );
  //if (n==8) savemesh(Th,"Cyl.mesh");

  fespace Uh(Th,[P1,P1,P1,P1]);
  fespace Vh(Th,P13d);
  
  macro Grad(u) [dx(u),dy(u),dz(u)]// EOM
  macro div(u1,u2,u3) (dx(u1)+dy(u2)+dz(u3)) //EOM
  macro norm(Th,u,exactu) (int3d(Th)(square(u-exactu))) //EOM
  macro normH(Th,u,exactu) (int3d(Th) ( (dx(u)-dx(exactu))^2 + (dy(u)-dy(exactu))^2 + (dz(u)-dz(exactu))^2 ) ) //EOM

  Uh [u1,u2,u3,p];
  Uh [v1,v2,v3,q];
  Vh u1old, u2old, u3old;
  Vh u1oldd, u2oldd, u3oldd;
  Vh u1star,u2star,u3star;
  Vh proju1,proju2,proju3;

  problem navierstokesinit ([u1,u2,u3,p],[v1,v2,v3,q]) = 
    int3d(Th) (u1*v1/dt) - int3d(Th) (convect([u1old,u2old,u3old],(-dt),u1old)*v1/dt)
  + int3d(Th) (u2*v2/dt) - int3d(Th) (convect([u1old,u2old,u3old],(-dt),u2old)*v2/dt)
  + int3d(Th) (u3*v3/dt) - int3d(Th) (convect([u1old,u2old,u3old],(-dt),u3old)*v3/dt)
  + int3d(Th,qforder=3)( nu*Grad(u1)'*Grad(v1) +  nu*Grad(u2)'*Grad(v2) +  nu*Grad(u3)'*Grad(v3) //)';
		       - div(u1,u2,u3)*q - div(v1,v2,v3)*p)
  - int3d(Th) ((f1*v1) + (f2*v2) + (f3*v3))
  - int3d(Th) (delta* hTriangle * hTriangle * Grad(p)'*Grad(q))
  + on(1,2,3,4,u1=exactu1,u2=exactu2,u3=exactu3);

  problem navierstokes ([u1,u2,u3,p],[v1,v2,v3,q]) = 
    int3d(Th) (3*u1*v1/(2*dt)) - int3d(Th) (convect([u1star,u2star,u3star],(-dt),u1old)*4*v1/(2*dt)) 
  + int3d(Th) (convect([u1star,u2star,u3star],(-2*dt),u1oldd)*v1/(2*dt))
  + int3d(Th) (3*u2*v2/(2*dt)) - int3d(Th) (convect([u1star,u2star,u3star],(-dt),u2old)*4*v2/(2*dt)) 
  + int3d(Th) (convect([u1star,u2star,u3star],(-2*dt),u2oldd)*v2/(2*dt))
  + int3d(Th) (3*u3*v3/(2*dt)) - int3d(Th) (convect([u1star,u2star,u3star],(-dt),u3old)*4*v3/(2*dt)) 
  + int3d(Th) (convect([u1star,u2star,u3star],(-2*dt),u3oldd)*v3/(2*dt))
  + int3d(Th,qforder=3)( nu*Grad(u1)'*Grad(v1) +  nu*Grad(u2)'*Grad(v2) +  nu*Grad(u3)'*Grad(v3) //)';
		       - div(u1,u2,u3)*q - div(v1,v2,v3)*p)
  - int3d(Th) ((f1*v1) + (f2*v2) + (f3*v3))
  - int3d(Th) (delta* hTriangle * hTriangle * Grad(p)'*Grad(q))
   + on(1,2,3,4,u1=exactu1,u2=exactu2,u3=exactu3);

  u1old = -cos(x)*sin(y)*cos(z) ;
  u2old = sin(x)*cos(y)*cos(z) ;
  u3old = 0;

  for ( int it = 1; it <= Nt; it++ )
  {
    t=it*dt;
    if (it==1) {navierstokesinit;}
    else {navierstokes;}

    proju1 = exactu1 ; proju2 = exactu2 ; proju3 = exactu3 ;
    error = sqrt( norm(Th,u1,exactu1) + norm(Th,u2,exactu2) + norm(Th,u3,exactu3));
    Herror = sqrt( error^2 + normH(Th,u1,proju1) + normH(Th,u2,proju2) + normH(Th,u3,proju3) );
    if (error > errormax) errormax = error ;
    if (Herror > Herrormax) Herrormax = Herror ;
    cout << "L2-error at " << t << "is " << error << "max = " << errormax << "\n" ;
    cout << "H1-error at " << t << "is " << Herror << "max = " << Herrormax << "\n"; 
    
    u1oldd = u1old; u2oldd = u2old; u3oldd = u3old; 
    u1old = u1; u2old=u2; u3old=u3;
    u1star = 2*u1old-u1oldd; u2star = 2*u2old-u2oldd; u3star = 2*u3old-u3oldd;
    
    if(n==20){
      plot ( Th, [u1,u2,u3], nbiso = 60, fill = 0, value = 1, wait = 0);
      savevtk("Cyl_NS_3D_plot"+n+"_"+it+".vtk",Th,[u1,u2,u3],p,dataname="Velocity");
      //plot (p, nbiso=60, fill =0, value =1, wait =0 );

      if (abs(u1)>abs(u2) && abs(u1)>abs(u3)) maxmag = abs(u1);
      else if (abs(u2)>abs(u1) && abs(u2)>abs(u3)) maxmag = abs(u2);
      else maxmag = abs(u3);
      umag << t << "\t" << maxmag << "\n" ;
      cout << u1 << "\t" << u2 << "\t" << u3 << "\t" << maxmag << "\n" ;
    }
  }
  ff << dt << "\t" << errormax << "\t" << Herrormax << "\n" ;
  
  cout << ">>>>>MESH>>>>> " << n << " executed \n" ;
  errormax = 0;
  Herrormax = 0;
}
//  Terminate.
//
cout << "\n";
cout << "NAVIERSTOKES:\n";
cout << "Normal end of execution.\n";
